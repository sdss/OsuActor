#added by CK 2021/03/30

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

from __future__ import annotations

import asyncio
import configparser
import os
import re
import warnings
from collections.abc import AsyncIterator

from typing import Any, Callable, Iterable, Optional

from osuactor.controller.command import OsuCommand
from . import MAX_COMMAND_ID

import numpy
from clu.device import Device

__all__ = ["OsuController"]


class OsuController(Device):
    """Talks to an Osu controller over TCP/IP.

    Parameters
    ----------
    host
        The hostname of the Osu.
    port
        The port on which the Osu Controller listens to incoming connections.
        Defaults to 7776.
    name
        A name identifying this controller.
    """

    __running_commands: dict[int, OsuCommand] = {}
    _id_pool = set(range(MAX_COMMAND_ID))

    def __init__(self, host: str, port: int = 7776, name: str = ""):
        Device.__init__(self, host, port)

        self.name = name
#        self._status: ControllerStatus = ControllerStatus.UNKNOWN
        self.__status_event = asyncio.Event()

#        self._binary_reply: Optional[bytearray] = None

        # TODO: asyncio recommends using asyncio.create_task directly, but that
        # call get_running_loop() which fails in iPython.
        self._job = asyncio.get_event_loop().create_task(self.__track_commands())

    def send_command(
        self,
        command_string: str,
        command_id: Optional[int] = None,
        **kwargs,
    ) -> OsuCommand:
        """Sends a command to the OsuController.

        Parameters
        ----------
        command_string
            The command to send to the Archon. Will be converted to uppercase.
        command_id
            The command id to associate with this message. If not provided, a
            sequential, autogenerated one will be used.
        kwargs
            Other keyword arguments to pass to `.ArchonCommand`.
        """

        command = OsuCommand(
            command_string,
            command_id,
            controller=self,
            **kwargs,
        )
        self.__running_commands[command_id] = command

        sclHead = chr(0)+chr(7)
        sclTail = chr(13)
        sclStr = sclHead + command_string.upper() + sclTail

        self.write(sclStr.encode())

        return command

    async def _listen(self):
        """Listens to the reader stream and callbacks on message received."""
        KeepGoing = True
        while KeepGoing:
                sclReply = ""
                data = await self.read(4096)
                recStr = data.decode()
                sclReply = recStr[2:-1]

                if sclReply[:4] == 'DONE':
                    print(sclReply[:4])
                    return True, sclReply
                if sclReply[:3] == 'ERR':
                    print(sclReply[:3])
                    return True, sclReply
                if sclReply[:2] == 'IS':
                    print(sclReply[:2])
                    return True, sclReply
        

    async def __track_commands(self):
        """Removes complete commands from the list of running commands."""
        while True:
            done_cids = []
            for cid in self.__running_commands.keys():
                if self.__running_commands[cid].done():
                    self._id_pool.add(cid)
                    done_cids.append(cid)
            for cid in done_cids:
                self.__running_commands.pop(cid)
            await asyncio.sleep(0.5)

